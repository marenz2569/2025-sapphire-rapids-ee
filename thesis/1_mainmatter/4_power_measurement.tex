\chapter{Power Measurement}

\section{Validating RAPL Accuracy}
Starting with the Haswell microarchitecture Intel integrated current measurement into their processors to support power limiting~\cite{Hackenberg_2015_Haswell}.
The associated power metrics for different zones can be measured using the RAPL interface via the linux kernel~\cite{powercap_kernel_doc}.
Schöne et al.~\cite{Schoene_2024_Alder_Lake} tried to validate that RAPL counters on the Alder Lake architecture rely on current measurements, however they found that they are likely using a model.
This is relevant to Sapphire Rapids, since they share the same core microarchitecture Golden Cove.

\begin{figure}[]
    \centering
    \includegraphics[width=0.8\columnwidth]{fig/rapl-accuracy/rapl-accuracy.pdf}
    \caption{\label{fig:validate-rapl}The roco2 microbenchmark is executed on a varying number of cores with different frequencies.
    The RAPL measurement can be mapped with a quadratic fit to the external reference measurement.}
\end{figure}

I validate the accuracy of these counters against an external measurement using roco2 synthetic workload generator.
This software required some patches to run on the current generation of processors.
They are documented in the forked GitHub repository~\footnote{\url{https://github.com/marenz2569/roco2/tree/marenz.hati-config}}.

Each of the displayed workload in~\figref{validate-rapl} were run for \SI{60}{\second} on the cross product of following settings:
\begin{itemize}
    \item Core frequency set to \SI{800}{\MHz}, \SI{1400}{\MHz}, \SI{2000}{\MHz} and \SI{3800}{\MHz} (turbo).
    \item Four settings which represent the execution of the workload on an increasing number of quadrants on the first socket.
    The number of cores used are: \SI{14}{}, \SI{28}{}, \SI{42}{} and \SI{56}{}.
\end{itemize}
The test matrix further included a full idle for each C-state setting (POLL, C1, C1E, C6).
Hyperthreading is disabled and the governor set to \texttt{performance}.
The power metrics were measured through the FIRESTARTER measurement inferface.
This polls the RAPL metrics every \SI{10}{\ms} and discovered the first and last \SI{5}{\second} of each measurement duration.
The external reference measurent of the PDU is exposed via the metricq~\cite{Ilsche_2019_MetricQ} interface of FIRESTARTER~\footnote{\url{https://github.com/marenz2569/firestarter-metric-metricq}} and reports \SI{1}{Sa\per\second}.
The average power draw of the PDU and the RAPL counters is plotted in~\figref{validate-rapl}.
A strong correlation via quadratic fit can be observed, indication that RAPL metrics are being measured.
All measurment points are inside the \SI{1}{\percent} tolerance of the PDU.

\section{RAPL Filters}

Energy measurement with high accuracy can be used to measure the energy difference between different executed instructions and their data.
This has been demonstrated in great detail~\cite{Lucas_2016_AluPower,Schoene_2024_Alder_Lake,Schoene_2021_Zen2}.
However it can also be used to perform side channel attacks and retrieve keys from priviledged programs~\cite{Lipp_2021_Platypus}.
While limiting access to the RAPL counters is possible from an operating system perspective, Intel also provides the option to enable filters \textbf{IA32\_MISC\_PACKAGE\_CTLS} on the energy measurement which cannot be deactived until a reboot is performed~\cite[Vol. 4 Table 2-52]{intel_combined_software_developer_manual}.
The third generation of Xeon Scalable processors (Ice Lake) introduced the \textbf{MSR\_PACKAGE\_ENERGY\_TIME\_STATUS} MSR which also contains an accurate time point when the register was last updated.
This should address the problem of accuratly measuring short code-paths as presented by Hähnel et al.~\cite{Haehnel_2012_RAPL}.

I extend the measurement for RAPL granularity propsed by Schöne et al.~\cite{Schoene_2024_Alder_Lake}.
All possible RAPL counters are polled repeatidly for \SI{10}{\s} on CPU 0 via their associated MSR.
CPU 1 runs FIRESTARTER to generate a constant power consumption on the processor.
The measurement is reapeated across the cross product of following settings:
\begin{itemize}
    \item All available core frequencies.
    \item With and without RAPL filters enabled.
    \item Both with all cstates and only POLL enabled.
    This causes two levels of power draw at the same frequency.
\end{itemize}
Only the counters \textbf{MSR\_PCKG\_ENERGY}, \textbf{MSR\_PACKAGE\_ENERGY\_TIME\_STATUS} and\\ \textbf{MSR\_RAM\_ENERGY} contain valid values.

I plot the package and dram counters for the nominal core frequency of \SI{2}{\GHz}.
\figref{rapl-update-intervals-package} shows the difference between the newly added timestamp in the model specific register\\ \textbf{MSR\_PACKAGE\_ENERGY\_TIME\_STATUS} and rdtsc as the source of the timestamp.
The counter is updated every \SI{1.5}{\ms}.
It is increased to \SI{3.0}{\ms} with filters enabled.
The higher energy consumption when only enabling POLL is clearly visible.
Under the constant load the timestamp of the RAPL register and the accumulated energy during this time follow a linear function, as is expect with accuracte timestamps.
Accurate timestamps seem to be deactived when the RAPL filter is enabled.
Dram counters displayed in \figref{rapl-update-intervals-dram} show an update interval of around \SI{1.6}{\ms}, this does not change with RAPL filters enabled.
They are not as accurate as the package counters, but also not not show such a big spead when using rdtsc as the timestamp source.

Data center and HPC administrators require accuracte energy accounting of larger code paths or accross multiple executions.
Software developers require it for fast runtime optimization of energy efficiency.
An increased accuracy of this measurement is possible with the use of the internal timestamp in the \textbf{MSR\_PACKAGE\_ENERGY\_TIME\_STATUS} register.
For use cases with security critical data and algorithms, I recommend to activate the filter increasing the barrier against leaks even if parts of the system are compromised.

\begin{figure}[]
    \centering
    % width could be 1, 0.9, 0.8 instead
    \includegraphics[width=\columnwidth]{fig/rapl-update-intervals/MSR_PACKAGE_ENERGY_TIME_STATUS_2000000.pdf}
    \caption{\label{fig:rapl-update-intervals-package}Kernel density estimation of the time of measurement vs read energy value of the RAPL package counter of the first socket during a constant power draw scenario.
    The time value is displayed for both the time from the timestamp instruction and the reported time the RAPL model specific register.}
\end{figure}

\begin{figure}[]
    \centering
    % width cloud be 0.54, 0.49, 0.44 instead
    \includegraphics[width=0.54\columnwidth]{fig/rapl-update-intervals/MSR_RAM_ENERGY_2000000.pdf}
    \caption{\label{fig:rapl-update-intervals-dram}Kernel density estimation of the time of measurement via timestamp counter and the read energy value of the RAPL dram counter of the first socket during a constant power draw scenario.}
\end{figure}